<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Flow Nodes (Advanced) </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Flow Nodes (Advanced) ">
    <meta name="generator" content="docfx 2.49.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
              
              <a href="https://github.com/Wibble199/VisualProgrammer" class="github-ribbon">
                <img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1">
              </a>    </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="flow-nodes-advanced">Flow Nodes (Advanced)</h1>

<p>Flow nodes are nodes which are capable of controlling the flow of program, such as choosing one of two branches to execute based on a condition (<code>if</code> statement) or repeating a set of nodes a certain number of times (<code>for</code> loop). There are very few circumstances where a custom flow node needs to be created for VisualProgrammer, but this article will detail how anyways.</p>
<p>When the VisualProgram compiler is generating the Linq Expression Tree for a program, it makes use of the <code>GetCompilerNextStatement</code> method that exists on all <code>VisualStatement</code>s. This method is overridable, but has a default implementation that simply returns the <em>NextStatement</em> StatementReference that also exists on all statements. When the compiler generates the expression tree for a particular entry, it will create a Block Linq expression and populate it with the expression generated by the first statement, then the next compiler statement from that statement, then the next compiler statement etc.</p>
<p>This default behaviour works fine for a simple program with only one branch, however when it encounters an <em>If</em> node, it shouldn't put all the true statements and all the false statements in the block because this will mean <strong>everything</strong> runs. To resolve this, the <em>If</em> node overrides the default behaviour of the <code>GetCompilerNextStatement</code>.</p>
<p>When designing the if statement, I wanted to make it as simple as possible. So, ideally I wanted to get rid of the &quot;Next statement&quot; reference so that less-experienced users do not struggle to understand which statement connector they need to join their nodes to. By reducing it to just &quot;True&quot; and &quot;False&quot; connectors, users can more easily see which branch does what, and then when they need to, they can just connect to two separate branches back together.</p>
<p>This means that to implement the <code>GetCompilerNextStatement</code>, the node needs to return the first common statement between both the branches. The node's generated expression needs to be a Linq <code>IfThenElse</code> expression, which needs to have all the statements unqiue to either branch.</p>
<p>As a basic example, imagine the program had the structure as shown on the image below on the left. The 'If' node needs to be able to convert this structure to the corresponding approximate expression tree shown below on the right.</p>
<p><img src="../../resources/images/flow-branch-simplified.png" alt="Program Structure">
<img src="../../resources/images/flow-branch-alternative.png" alt="Expression Tree Structure"></p>
<p>There are some helper methods that have been added to the <code>NodeUtils</code> class to help with achieving this. <code>NodeUtils.FlattenExpressions</code> takes a context and two statement references and creates a collection of Linq expressions (that can be added into a Linq Block expression) for all nodes up to the first common shared node between them. Additionally, there is a <code>NodeUtils.FindNextSharedNode</code> method which takes a context and two statement references and returns the first statement that is common to both branches. Note that these methods use <code>GetNextCompilerStatement</code> so nesting If statements works as expected. Using these two methods, the If statement can be implemented correctly. Below is that implementation (commented):</p>
<pre><code class="lang-cs">public sealed class If : VisualStatement {

	// This is our expression that will be evaluated to determine which branch gets executed
	[VisualNodeProperty] public ExpressionReference&lt;bool&gt; Condition { get; set; }

	// These two references allow the user to connect the if node to other statements
	[VisualNodeProperty] public StatementReference TrueBranch { get; set; }
	[VisualNodeProperty] public StatementReference FalseBranch { get; set; }

	public override Expression CreateExpression(VisualProgram context) {
		// Get a tuple that contains two IEnumerable&lt;System.Linq.Expression&gt; that have the expressions that are unique to each branch.
		// If this was called on the above example structure, the `branch1Flattened` value on the tuple would contain the &quot;B&quot; statement
		// and the `branch2Flattened` value would contain the &quot;C&quot; and &quot;D&quot; statements.
		var branches = NodeUtils.FlattenExpressions(context, TrueBranch, FalseBranch);

		// Create an IfThenElse expression which first requires the condition expression (i.e. true/false)
		// Then also provide it with two blocks that contain the flattened statements
		return Expression.IfThenElse(
			Condition.ResolveRequiredExpression(context),
			Expression.Block(branches.branch1Flattened),
			Expression.Block(branches.branch2Flattened)
		);
	}

	// The next compiler statement is the first statement that is common between both branches.
	// If this was run on the example structure above, this would get the statement reference for &quot;E&quot; statement.
	public override StatementReference? GetCompilerNextStatement(VisualProgram context) =&gt; NodeUtils.FindNextSharedNode(context, TrueBranch, FalseBranch);

	// We override the NextStatement property which means that the [VisualNodeProperty] attribute is no longer applied (since that attribute is not inherited)
	// This causes the &quot;NextStatement&quot; to be hidden on the node, preventing users from connecting to it
	public override StatementReference NextStatement { get =&gt; default; set { } }
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Wibble199/VisualProgrammer/blob/f8ef031d21c4076529e15639a09e6b905f78410e/Docs/devguide/extension/flow-nodes.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
